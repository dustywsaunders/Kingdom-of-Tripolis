'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('howler'),
    Howl = _require.Howl;

var _require2 = require('./utils'),
    isObjectWithValues = _require2.isObjectWithValues;

module.exports = {
  removeId: function removeId(id) {
    var _this = this;

    Object.keys(this.playing).forEach(function (key) {
      return _this.playing[key].delete(id);
    });
  },
  initialize: function initialize(soundsData) {
    var _this2 = this;

    var soundOptions = void 0;
    // { String: Set[Integer] } Map of currently playing ids for each unique sound name
    // Can also use `new Map()`
    this.playing = Object.create(null);
    var soundNames = Object.getOwnPropertyNames(soundsData);
    this.sounds = soundNames.reduce(function (memo, name) {
      soundOptions = soundsData[name];

      // Allow strings instead of objects, for when all that is needed is a URL
      if (typeof soundOptions === 'string') {
        soundOptions = { src: [soundOptions] };
      }

      var sprites = soundOptions.sprite;
      if (isObjectWithValues(sprites)) {
        Object.keys(sprites).forEach(function (spriteName) {
          _this2.playing[name + spriteName] = new Set();
        });
      } else {
        _this2.playing[name] = new Set();
      }
      return _extends({}, memo, _defineProperty({}, name, new Howl(_extends({}, soundOptions, {
        onend: function onend(id) {
          if (soundOptions.onend) {
            soundOptions.onend(id);
          }
          _this2.removeId(id);
        },
        onstop: function onstop(id) {
          if (soundOptions.onstop) {
            soundOptions.onstop(id);
          }
          _this2.removeId(id);
        }
      }))));
    }, {});

    return this.sounds;
  },
  proxy: function proxy(soundName, spriteName, name) {
    var sound = this.sounds[soundName];
    if (typeof sound === 'undefined') {
      return console.warn('\n      The sound \'' + soundName + '\' was requested, but redux-sounds doesn\'t have anything registered under that name.\n      See https://github.com/joshwcomeau/redux-sounds#unregistered-sound\n    ');
    }
    if (spriteName && typeof sound._sprite[spriteName] === 'undefined') {
      var validSprites = Object.keys(sound._sprite).join(', ');
      return console.warn('\n      The sound \'' + soundName + '\' was found, but it does not have a sprite specified for \'' + spriteName + '\'.\n      It only has access to the following sprites: ' + validSprites + '.\n      See https://github.com/joshwcomeau/redux-sounds#invalid-sprite\n    ');
    }
    if (name === 'play') {
      return this.play(soundName, spriteName);
    }

    for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    return this.howlMethod.apply(this, [soundName, spriteName, name].concat(args));
  },
  play: function play(soundName) {
    var spriteName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    var sound = this.sounds[soundName];
    var id = sound.play(spriteName || undefined);
    if (this.playing[soundName + spriteName]) {
      this.playing[soundName + spriteName].add(id);
    }
    return id;
  },
  howlMethod: function howlMethod(soundName) {
    for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    var spriteName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var method = arguments[2];

    var sound = this.sounds[soundName];
    if (this.playing[soundName + spriteName]) {
      this.playing[soundName + spriteName].forEach(function (id) {
        sound[method].apply(sound, args.concat([id]));
      });
    } else {
      sound[method].apply(sound, args);
    }
  }
};